## 索引：

- 不适合⽤索引的场景
  - 不适合键值较少的列（重复数据较多的列）
  - 索引⽆法存储null值

- 索引失效的经典场景
    - 如果条件中有or，即使其中有条件带索引也不会使⽤(这也是为什么尽量少⽤or的原因)，要想使⽤or，⼜想让索引⽣效，只能将or条件中的每个列都加上索引
    - 对于多列索引，不是使⽤的第⼀部分，则不会使⽤索引
    - like查询以%开头
    - 类型强转情况下不⾛索引，如varchar类型⽤long传参来查
    - hash索引不⽀持范围检索  



## SQl 优化：

- SQL优化可以分为两部分，一个设计阶段，另一个是查询阶段
- 设计阶段运用的优化：
  - 使用适当的数据库列类型和大小
  - 尽量从设计上采用单表查询解决业务问题
  - 在适当字段加入索引，能用唯一索引用唯一索引
- 查询阶段设计的优化：
  - 尽可能不用`select * `: 让优化器无法完成索引覆盖扫描这类优化，而且还会增加额外的I/O 、内存和cpu消耗。
  - 慎用join操作：单张表查询可以减少锁的竞争，更容易应对业务的发展，方便对数据库进行拆分
  - 慎用子查询和临时表： 未带索引的字段上的 `group by `操作，`union` 查询，部分`order by `操作，例如`distinct` 函数和`order by ` 一起使用且 `distinct` 和 `order by` 同一个字段
  - 尽量不使用`limit` ，部分场景可以改用 `between and`





## explain 分析sql执行计划：

Extra 执行计划可能出现的值:

1. Using where：表示优化器需要通过索引回表查询数据。
2. Using index：即覆盖索引，表示直接访问索引就⾜够获取到所需要的数据，不需要通过索引回表，通常是通过将待查询字段建⽴联合索引实现。
3. Using index condition：在5.6版本后加⼊的新特性，即索引下推，是MySQL关于 减少回表次数的重⼤优化。
4.  Using filesort:⽂件排序，这个⼀般在ORDER BY时候，数据量过⼤， MySQL会将所有数据召回内存中排序，比较消耗资源。  

## 深度分页： 

- 比如1000000条数据，通过limit 获取 第8000000 之后10条记录。如果再加上where条件，就会很慢很慢，mysql会先把满足条件的数据查出放到内存，然后进行排序分页返回。

解决方案：

- 如果是自增主键，可以通过where条件加上主键优化，比如要获取 8000000到8000010 这10条记录，可以加上 id>8000000 类似这种优化，通过主键索引减少查询的数量，提高速度
- Elastic Search 搜索引擎优化（倒排索引）
- 实际上电商公司都把所有商品房间ES 搜索引擎的（海量的数据不可能放mysql也不能放redis） ，即使用了es所有引擎，还有可能发生深度分页问题，这时候需要通过 **游标scroll** 解决。

