## 数据库基础03——数据表操作

### 1、建表之前需要思考的基本问题

> - 表里会包含什么类型的数据？
> - 表的名称是什么？
> - 哪个（或哪些） 列组成主键？
> - 列（字段） 的名称是什么？
> - 每一列的数据类型是什么？
> - 每一列的长度是多少？
> - 表里哪些列可以是NULL？ 
> - 遵循每个DBMS的命名规则

### 2、建表语句CREATE TABLE

> create table 表名（
>
> ​	字段名 	类型（长度）	[约束],
>
> ​	字段名 	类型（长度）[约束]
>
> );

例如下面的建表语句：

```sql
CREATE TABLE Products
(
prod_id CHAR(10) NOT NULL,
vend_id CHAR(10) NOT NULL,
prod_name CHAR(254) NOT NULL,
prod_price DECIMAL(8,2) NOT NULL,
prod_desc VARCHAR(1000) NULL
);
```

注意：不同的DBMS 的建表语句是有差异的，上面的sql在Oracle、PostgreSQL、SQL Server 和 SQLite
中有效，**而对于 MySQL， varchar 必须替换为 text**； 因为MySQL中，VARCHAR表示长度可变，最多不超过255字节。所以这里的1000就需要用到大文本的text。

**命名规范：表和列的名称， 应该让名称反应出所保存的数据 **

### 3、创建自增长的列

MySQL 提供了 **SERIAL** 方法为表生成真正的唯一值 ：

```sql
CREATE TABLE TEST_INCREMENT(
	ID			SERIAL,				--这里不声明就是默认为null,如果not null必须明确指定
    TEST_NAME	VARCHAR(20));
```

Microsoft SQL Server中可以使用 **IDENTITY**类型：

``` sql
CREATE TABLE TEST_INCREMENT(
	ID		INT  IDENTITY(1,1) NOT NULL,
    TEST_NAME	VARCHAR(20);
```

Oracle 没有提供直接的方法来创建自动增加的列。 但却可以使用 **SEQUENCE** 对象和一个触发器来实现类似的效果。  

### 4、ALTER TABLE命令 （修改表）

表创建以后，我们可以使用alter table命令添加列、 删除列、 修改列定义、 添加和去除约束， 在某些实现中还可以修改表STORAGE值。  

首先说明下mysql的 alter 语句；

```sql
alter table 表名   add 列名  类型（长度） [约束]；--修改表添加列
alter table 表名	 modify 列名 类型（长度） [约束]；--修改表修改列的类型长度及约束
alter table 表名	change 旧列名	新列名	类型(长度) 约束；  --修改表修改列名
alter table 表名	drop  列名;						--修改表删除列
rename table 表名  to  新表名;						--修改表名
alter  table 表名	character set 字符集;				--修改表的字符集
```

**（1）修改数据类型**

要改变表中列的数据类型，请使用下面的语法：

**SQL Server / MS Access：**修改表修改列的类型长度及约束

```sql
ALTER TABLE 表名
ALTER COLUMN 列名 类型
```

**My SQL / Oracle：**修改表修改列的类型长度及约束

```sql
ALTER TABLE 表名
MODIFY COLUMN 列名 类型
```

**Oracle** 10G 之后版本:修改表修改列的类型长度及约束

```sql
ALTER TABLE 表名 MODIFY 列名 类型;
alter table tableName modify (cloumnName 数据类型); -- 修改数据类型
```

**（2）添加列、删除列**

如果表已经包含数据， 这时添加的列就不能定义为NOT NULL ， 强行向表添加一列的方法如下：
1． 添加一列， 把它定义为NULL（这一行不一定要包含数据） ；
2． 给这个新列在每条记录里都插入数据；
3． 把列的定义修改为NOT NULL。 

如需在表中添加列，请使用下面的语法:

```
ALTER TABLE 表名   ADD 列名 类型
```

如需**删除表中的列**，请使用下面的语法（**请注意，某些数据库系统不允许这种在数据库表中删除列的方式**）：

```
ALTER TABLE 表名  DROP COLUMN 列名
--至少mysql  sqlserver  oracle是允许的
```

**SQL server 中修改字段名**：

```sql
execute sp_rename '表名.旧字段名','新字段名'
```

MySQL修改字段名：

```sql
alter table 表名	change 旧列名	新列名	类型(长度) 约束；  --修改表修改列名
```

Oracle修改字段名：

```sql
alter table tableName rename column oldCName to newCName; -- 修改字段名
```

### 5、从现有表新建另一个表 

语法如下：

```sql
create table  新表名 as       
select [*|column1,column2...]	--可以是部分字段也可以是所有字段
from  表名
[where]							--可以添加条件
```

**MySQL和Oracle**都支持使用**CREATE   TABLE   AS    SELECT**方法， 在一个表的基础上创建另一个表。 但是
**Microsoft SQL Server**却不一样， 它使用**SELECT…INTO**方法来实现相同的效果。 

SQLserver如下：

```sql
select [*|column1,column2]
into  新表名
form 旧表名
[where]
```

### 6、删除表

如果使用了RESTRICT选项， 并且表被视图或约束所引用， DROP语句就会返回一个错误。

 当使用了CASCADE选项时， 删除操作会成功执行， 而且全部引用视图和约束都被删除。  

```sql
drop table table_name [restrict|cascade]
```

在SQL Server中， 不能使用CASCADE选项。 因此， 要在SQL Server中删除表， 必须同时删除与该表有
引用关系的所有对象， 以避免系统中遗留无效对象。 

### 7、完整性约束

- 主键约束
- 唯一性约束
- 外键约束
- NOT NULL 约束
- 检查约束

(1)**主键约束**：主键是表里一个或多个用于实现记录唯一性的字段。（可以一个，也可以多个） 

​	要求被修饰的字段 唯一、非空

```sql
CREATE TABLE EMPLOYEE_TBL(
	EMP_ID		CHAR(9)   NOT NULL PRIMARY KEY,-- 这里的主键是个隐含约束
	EMP_NAME	VARCHAR(40) NOT NULL
);
--还可以明确指定主键
CREATE TABLE EMPLOYEE_TBL(
	EMP_ID		CHAR(9)   NOT NULL,
	EMP_NAME	VARCHAR(40) NOT NULL，
    PRIMARY KEY(EMP_ID)
);
/*如果多个字段也可以用以下两种方式之一来定义*/--以下在oracle数据库是可行的
CREATE TABLE PRODUCT_TST(
	PROD_ID		VARCHAR2(10) NOT NULL,
    VEND_ID		VARCHAR2(30) NOT NULL,
    PRODUCT		VARCHAR2(10) NOT NULL,
    PRIMARY KEY(PROD_ID,VEND_ID)
)--或者
ALTER TABLE PRODUCTS_TST
ADD CONSTRAINT	PRODUCTS_PK PRIMARY KEY (prod_id,VEND_ID)

```

(2)唯一性约束

唯一性约束要求表里某个字段的值在每条记录里都是唯一的 。主键必须唯一，唯一不一定是主键。

```sql
CREATE TABLE EMPLOYEE_TBL(
	EMP_ID		CHAR(9)   NOT NULL PRIMARY KEY,
	EMP_NAME	VARCHAR(40) NOT NULL  UNIQUE-- 举个例子，直接加 UNIQUE字句就行
);
```

(3)外键约束

外键是子表里的一个字段， 引用父表里的主键。 外键约束是确保表与表之间引用完整性的主要机制。
一个被定义为外键的字段用于引用另一个表里的主键。 举个例子：

```sql
CRATE TABLE EMPLOYEE_PAY_TST(
	EMP_ID		CHAR(9)		NOT NULL,
    POSITION	VARCHAR(15)	NOT NULL,
    DATE_HIRE	DATE		NULL,
    PAY_RATE	NUMBER(4,2)	NOT NUL,
    CONSTRAINT	EMP_ID_FK	FOREIGN KEY(EMP_ID) REFREENCES EMPLOYEE_TBL(EMP_ID)
    --这里 是把此表的 EMP_ID作为EMPLOYEE_TBL作为的外键，于EMPLOYEE_TBL 的EMP_ID一一对应
);
```

注意：子表里的EMP_ID字段引用父表里的EMP_ID字段。 为了在子表里插入一个EMP_ID的值， 它首先要存在于父表的EMP_ID里。 类似地， 父表里删除一个EMP_ID的值， 子表里相应的EMP_ID值必须全部被删除。 这就是**引用完整性的概念** 

还可以利用ALTER TABLE 命令向表里添加外键

```sql
alter table employee_pay_tbl add constraint id_fk foreign key(emp_id)
references employee_tbl(emp_id)
--语法
alter table 从表名  add  constraint 外键名(自己起) foreign key(外键)
references 主表名(主键)
```

(4)NOT NULL 约束：例子中已经展示，not null就行

(5)检查约束

检查（CHK） 约束用于检查输入到特定字段的数据的有效性， 可以提供后端的数据库编辑。 检查约束为数据提供了另一层保护。 

```sql
CRATE TABLE EMPLOYEE_PAY_TST(
	EMP_ID		CHAR(9)		NOT NULL,
    POSITION	VARCHAR(15)	NOT NULL,
    DATE_HIRE	DATE		NULL,
    PAY_RATE	NUMBER(4,2)	NOT NUL,
    EMP_ZIP		NUMBER(5)	NOT NULL,
    CONSTRAINT CHK_EMP_ZIP	CHECK(EMP_ZIP='12345')
    --这个检查约束就是保证输入到这个表的数据的emp_zip都是‘12345’，只是个例子，知道这么用就行
    --在检查约束里可以使用几乎任何条件，就像在SQL查询里一样。 check(条件)
);
```

(6)去除约束

利用ALTER TABLE命令的DROP CONSTRAINT选项可以去除已经定义的约束。 

```sql
ALTER TABLE EMPLOYEES DROP CONSTRAINT EMPLOYEES_PK;--这里就是去掉了empoyees表中的employees_pk的主键约束。
```

如果要删除外键约束：

```sql
ALTER TABLE 表名 DROP CONSTRAINT 外键约束名;--所以添加约束的时候最好起起个约束名，不然不好删
```

















